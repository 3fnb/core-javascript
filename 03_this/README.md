# 3장. this

<br/>

## Intro

<br>

왜 실행 컨텍스트 다음 단원이 this일까?

> 실행 콘텍스트를 알아야 this가 왜 이건지 정확히 알 수 있어서.

<br>

this는 왜 헷갈릴까?

> **변수**들은 스코프체인을 따라 직관적으로 탐색한다. (자신의 렉시컬 환경에 존재하지 않으면 outer environment reference를 보고 변수를 찾는다.)  
> **this**는 실행컨텍스트 생성 시 this가 보이지 않으면, 스코프체인을 따라 가장 가까운 this를 찾지 않고 그냥 전역 객체를 바인딩 해버린다.

<br>

this는 그래서 이름 그대로 움직이는 것이 아닌, 함수 실행시(정확하게는 실행컨텍스트 생성 시) this가 무엇인지 지정 해주었냐에 따라 바뀌게 된다.

<br>

## 4가지로 나눈 this

위에서도 말했듯, this는 함수 호출 시 결정된다. 어떤 방식으로 호출하냐에 따라 달려있다.

<br/>

### 1. 전역에서의 this

**this 는 전역 객체이다.** 브라우저 환경에서는 `window` node 환경에서는 `global`

책에서는 추가로 var의 암묵적 전역을 소개하고 있다.  
var로 선언한 변수는 전역객체의 프로퍼티로 할당이 되어 전역객체를 오염시킨다.
let으로 선언한 변수는 전역객체에 할당되지 않고, 렉시컬 환경의 environment record에 존재한다.

전역객체는, 그냥 커다란 객체인데 전역변수, 함수, DOM을 보관하고 관리하는 곳.
(추가로, strict mode일때 함수 안에서 실행되는 this는 undefined)

<br/>

### 2. 메소드로 호출, 함수로 호출

메서드와 함수는 독립성의 차이가 있다.
객체는 프로퍼티와 메서드로 구성되는데, 동작과 속성을 한번에 정의한것.
그렇기에 메소드는 호출한 대상 객체에 관한 동작을 수행한다.

주의할 점은, 객체 안에 있는 메소드를, 메소드로 호출할 수도 있지만, 함수로도 호출할 수 있다.

메소드로 호출된건 어떻게 알지 . . ? 라고 생각한다면
`객체.메소드()` 로 실행될때가 메소드로 호출된 것. (dot notation, bracket notation 모두 가능)

메소드를 변수에 담아 `메소드()`로 실행된다면 함수로 호출된것.

#### **대안**

1. 메소드 내부 함수에서도 this를 부를 경우 전역객체가 바인딩 되는데, 이를 우회하기 위한 방법으로 this를 that, self 같은 변수에 할당해놓고 쓰는 경우도 있다.

2. 실행컨텍스트 생성시 this를 바인딩하지 않는 화살표 함수는 직관적으로 가장 가까운 this를 바인딩한다.

<br/>

### 3. 콜백함수 내부에서의 this

콜백함수는 제어권을 함수에게 넘기는것. 따라서 기본적으로 this는 전역객체이지만, 함수가 정한대로 별로도 this를 지정해 줄 수도 있다.

1. eventListner 안에서의 this는 e.currentTarget이라고 정해져있다.
2. 배열 메소드중에는 인자로 this를 받는 함수들도 있다. foreach 등.

<br/>

### 4. 생성자 함수 내부의 this

생성자 함수는 객체를 찍어내는 기계같은것. this는 새로 만들어지는 인스턴스를 가리킨다.

<br>

## 명시적인 this 바인딩

### call, apply, bind

#### **call**

    func.call(thisArg[, arg1[, arg2[, ...]]])

call은 함수를 즉시 실행하도록 한다.  
첫번째 인수는 this, 두번째부터는 실행하는 함수의 인수를 넣어준다.  
임의로 this를 지정해 줄 수 있다.

#### **apply**

    func.apply(thisArg, [argsArray])

> 주의: 이 함수 구문은 apply()와 거의 동일하지만, call()은 인수 목록을, apply()는 인수 배열 하나를 받는다는 점이 중요한 차이점.

1. call, apply를 통해 유사배열객체에 배열 메소드를 사용할 수 있다.  
   (arguments(나머지 연산자로 대체 가능), NodeList등이 유사배열 객체이다.)

2. 생성자 함수 내부에서 다른 생성자 함수를 호출 할 수있다.

3. apply를 활용해 여러개의 인수를 받는 함수를 배열 하나로 줄 수 있다.  
   `Math.max()` 는 인수 여러개를 받는다. Math.max(1,2,3) 여기서 apply를 활용하면 배열로 인수를 넣어줄 수 있다. (나머지 연산자로 대체 가능하다.)

#### **bind**

    func.bind(thisArg[, arg1[, arg2[, ...]]])

위 두 함수와 다른점은, 즉시 실행하지 않고 함수를 반환한다는 점.  
bind를 통해 반환된 함수는 name 프로퍼티를 갖는데, `bound 원함수` 와 같은 형식이다.

<br>
<br>

참고한 곳 : mdn
