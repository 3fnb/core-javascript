# 2장. 실행 컨텍스트

<br/>

## 실행컨텍스트(execution context)

실행할 코드에 제공할 환경 정보들을 모아놓은 `객체`이다. 이를 잘 이해하면 호이스팅, 스코프, 클로저, this를 깊이있게 이해할 수 있다.

<br/>

### 스택(stack)& 큐(queue)

- 스택 ⇒ 후입선출
- 큐 ⇒ 선입선출

실행컨텍스트는 스택을 채용하여 관리되고 있다.

<br/>

### 실행컨텍스트을 생성하는 3가지 방법

- 자동생성되는 전역공간
- eval() ⇒ 비추
- 함수 실행

실질적으로 새로운 실행컨텍스트가 생성되는 때는 `함수가 실행 될 때` 뿐이다.

<br/>

## ⭐️ 실행컨텍스트(객체)의 구조 ⭐️

### VE(Variable Environment) ⇒ snapshot

- environmentRecord
- outerEnvironmentReference

<br/>

### LE(Lexical Environment) ⇒ 동적으로 변함

- environmentRecord: 컨텍스트 내부의 이름 정보(변수, 매개변수, 함수) → 호이스팅
- outerEnvironmentReference: 컨텍스트 외부의 식별자 정보 → 스코프

<br/>

### this binding

- this가 가리키는 객체정보
- 해당 함수(실행컨텍스트)가 메서드로 호출되었느냐 함수로 호출되었느냐에 따라 달라짐

<br/>

## 함수 선언 방식 2가지

### 함수 선언문

```jsx
function a() {
	...
}
```

<br/>

### 함수 표현식

```jsx
var a = function() {
	...
}
```

- 함수 선언문 = 함수명 등록 + 코드 할당 → (1회차)
- 함수 표현식 = 변수명 식별자 등록(1회차) → 함수코드 할당(2회차)

<br/>

## 호이스팅(hoisting)

자바스크립트는 실행컨텍스트를 2번 스캐닝 하는데 1회차 스캐닝에 식별자 정보만 수집하고, 2회차에는 스캐닝하면서 실제로 코드를 실행시킨다. 1회차 때 식별자 정보를 모두 수집한 후 실행시키다보니 아직 선언되지 않은 변수를 참조해도 에러가 발생하지 않고 참조되는 현상일 발생하는데 이를 호이스팅이라고 한다. 사실 자바스크립트 엔진이 코드를 실행하는 과정에서 위로 끌어올리는 행위는 하지 않지만, 마치 위로 끌어올리는 듯한 현상이 나타나서 hoisting이라고 부르게 되었다.

<br/>

### 실행순서 연습

```jsx
function test() {
  console.log(a); // 1️⃣
  var a = 'hello!';
  console.log(a); // 2️⃣
  function a() {}
  console.log(a); // 3️⃣
}
```

1~3에는 각각 무엇이 찍힐까?

<br/>

## 스코프체이닝(scope chaining)

스코프는 변수의 유효범위를 나타낸다. 실행컨텍스트상에서 변수참조가 일어나면 해당 컨텍스트상의 스코프에서 변수를 검색한다. 혹시 찾지 못하면 상위 스코프 상에서 검색을 시작하며 이러한 과정은 변수를 찾거나 전역스코프에 도달할 때까지 반복되는데 이를 스코프 체이닝이라고한다. 스코프 정보는 실행컨텍스트 - LE - outerEnvironmentReference 안에 저장되어 있으며, 링크드리스트(Linked List)라는 자료구조의 형태를 띈다.

<br/>

### 전역변수와 지역변수

전역 실행컨텍스트에서 선언된 변수를 전역변수, 그 이후에 생성된 실행컨텍스트 혹은 블록스코프에서 선언된 변수를 지역변수라고 한다. 전역변수는 코드안전성을 위하여 가급적 사용하지 않는 것이 좋다. 반드시 사용해야한다면 즉시실행함수(IIFE)를 사용하는 것이 좋다.

<br/>

### 변수 은닉화(variable shadowing)

하위 컨텍스트에서 전역변수와 동일한 변수명으로 지역변수를 선언하면 스코프 참조시 지역변수를 참조하게 되고 전역변수는 해당 컨텍스트가 종료 될 때 까지 참조할 수 없는 상태가 되는데, 이를 변수 은닉화라고 부른다.
